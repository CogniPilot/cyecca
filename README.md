# cyecca

**Cy**mbolic **E**stimation and **C**ontrol with **C**omputer **A**lgebra

A Python library for code generation and analysis from flattened Modelica models, with native support for Lie group structures (SE(2,3), SO(3), etc.).

## Purpose

Cyecca is a **code generation backend** for Modelica compilers, specifically designed to:

1. **Consume Base Modelica IR**: Import standardized [Base Modelica JSON](https://github.com/modelica/ModelicaSpecification/blob/MCP/0031/RationaleMCP/0031/) from compilers like [Rumoca](https://github.com/CogniPilot/rumoca)
2. **Support Lie Groups**: Native annotations for manifold-aware simulation and control (SE(2,3) for rigid body dynamics)
3. **Generate Efficient Code**: Multiple backends (CasADi, SymPy, JAX) for numerical computation and symbolic analysis
4. **Enable Analysis**: Simulation, linearization, reachability analysis, and visualization tools

## Why Base Modelica?

Cyecca's IR is aligned with **Base Modelica** ([MCP-0031](https://github.com/modelica/ModelicaSpecification/blob/MCP/0031/RationaleMCP/0031/)) for:

- ✅ **Standardization**: Tool-agnostic interchange format
- ✅ **Simplicity**: Flattened, DAE-ready representation (no connect equations, hierarchical models, etc.)
- ✅ **Extensibility**: Supports domain-specific annotations (Lie groups for manifold-aware solvers)
- ✅ **Future-proof**: Aligned with emerging Modelica ecosystem standards

Cyecca extends Base Modelica with **Lie group annotations** for manifold-aware code generation, enabling geometrically correct simulation of rigid body systems.

## Architecture

```
Modelica Source (.mo files)
        ↓
    Rumoca Compiler (parsing, flattening, connect expansion)
        ↓
    Base Modelica JSON (MCP-0031 + Lie group annotations)
        ↓
    Cyecca IR (Python)  ← You can also write IR directly via DSL
        ↓
   Backend Selection (CasADi, SymPy, JAX, etc.)
        ↓
   Code Generation & Analysis (Simulation, Linearization, C++ export)
```

## Quick Start

### Option 1: Import from Base Modelica JSON (recommended)

```python
from cyecca.io.base_modelica import import_base_modelica
from cyecca.backends.casadi import CasadiBackend

# Import model from Base Modelica JSON (generated by Rumoca)
model = import_base_modelica("path/to/model.json")

# Compile to backend and simulate
backend = CasadiBackend(model)
t, sol = backend.simulate(t_final=10.0, dt=0.01)

print(f"Model: {model.name}")
print(f"States: {len(model.states)}")
print(f"Lie groups: {model.metadata.get('lie_groups', {})}")
```

### Option 2: Using the IR directly (programmatic model creation)

```python
from cyecca.ir import Model, Variable, Equation, VariableType
from cyecca.backends.casadi import CasadiBackend
from cyecca.simulation import simulate

# Create model programmatically (this is what Rumoca generates)
model = Model(name="MassSpringDamper")

# Define variables
model.add_variable(Variable(name="x", var_type=VariableType.STATE, start=1.0))
model.add_variable(Variable(name="v", var_type=VariableType.STATE, start=0.0))
model.add_variable(Variable(name="F", var_type=VariableType.INPUT))
model.add_variable(Variable(name="m", var_type=VariableType.PARAMETER, value=1.0))
model.add_variable(Variable(name="c", var_type=VariableType.PARAMETER, value=0.1))
model.add_variable(Variable(name="k", var_type=VariableType.PARAMETER, value=1.0))

# Define equations using expression builders
from cyecca.ir import Expr

x_ref = Expr.var_ref("x")
v_ref = Expr.var_ref("v")
F_ref = Expr.var_ref("F")
m_ref = Expr.var_ref("m")
c_ref = Expr.var_ref("c")
k_ref = Expr.var_ref("k")

# der(x) = v
model.add_equation(Equation.derivative("x", v_ref))

# der(v) = (F - c*v - k*x) / m
force = Expr.binary_op("-", F_ref, Expr.binary_op("*", c_ref, v_ref))
force = Expr.binary_op("-", force, Expr.binary_op("*", k_ref, x_ref))
accel = Expr.binary_op("/", force, m_ref)
model.add_equation(Equation.derivative("v", accel))

# Compile to backend
backend = CasadiBackend(model)
t, sol = backend.simulate(t_final=10.0, dt=0.01)

print(f"Final position: {sol['x'][-1]:.6f}")
```

### Option 3: Using the DSL (for prototyping)

```python
from cyecca.dsl import model, State, Input, Parameter, der

@model
class MassSpringDamper:
    # Variables
    x: State = 1.0  # position
    v: State = 0.0  # velocity
    F: Input        # force

    # Parameters
    m: Parameter = 1.0
    c: Parameter = 0.1
    k: Parameter = 1.0

    # Equations
    def equations(self):
        der(self.x, self.v)
        der(self.v, (self.F - self.c * self.v - self.k * self.x) / self.m)

# Use it
msd = MassSpringDamper()
t, sol = msd.simulate(t_final=10.0, dt=0.01)
```

## Features

### IR Layer (`cyecca.ir`)
- **Variable**: States, inputs, outputs, parameters, algebraic variables
- **Expression**: Mathematical expressions with type safety
- **Equation**: Differential, algebraic, discrete equations
- **Model**: Container for variables and equations
- **FlatModel**: Flattened representation ready for code generation

### Backends (`cyecca.backends`)

#### CasADi Backend
Fast numerical computation:
- Numerical optimization and simulation
- Automatic differentiation
- C code generation for embedded systems
- State-space linearization

```python
from cyecca.backends.casadi import CasadiBackend
backend = CasadiBackend(model)
backend.compile()
t, sol = backend.simulate(t_final=10.0, dt=0.01)
A, B, C, D = backend.linearize()
```

#### SymPy Backend (optional, requires `sympy`)
Symbolic analysis and manipulation:
- Symbolic Jacobian computation
- Expression simplification
- LaTeX export for documentation
- Taylor series expansion
- Analytical derivatives

```python
from cyecca.backends.sympy import SympyBackend
backend = SympyBackend(model)
backend.compile()

# Get symbolic Jacobian
A_sym = backend.get_jacobian_state()

# Export to LaTeX
latex = backend.to_latex("x", simplified=True)

# Taylor series expansion
taylor = backend.taylor_series("omega", around={"theta": 0.0}, order=3)
```

See `examples/sympy_analysis.py` for a complete demonstration.

### Analysis Tools
- **Simulation**: ODE/DAE integration with event detection
- **Linearization**: Extract state-space matrices (A, B, C, D)
- **Stability**: Eigenvalue analysis, phase portraits
- **Plotting**: Integrated visualization tools

### DSL (`cyecca.dsl`)
- Modelica-inspired Python decorators
- Type-safe model definitions
- Automatic IR generation
- Useful for prototyping before Rumoca is feature-complete

## Installation

```bash
git clone https://github.com/CogniPilot/cyecca.git
cd cyecca
poetry install

# With optional dependencies
poetry install --extras "all"
```

## Development Status

This is the v2 rewrite focused on:
1. Clean IR for Rumoca integration
2. Pluggable backend architecture
3. Engineering-friendly API
4. Comprehensive testing

## Comparison with v1

**v1 (old)**: Focused on Lie groups and direct CasADi usage, tightly coupled

**v2 (this)**: Clean IR layer, multiple backends, designed as compiler target

## License

MIT License - See LICENSE file

## Citation

```bibtex
@software{cyecca,
  title = {cyecca: Symbolic Estimation and Control with Computer Algebra},
  author = {Goppert, James},
  organization = {CogniPilot},
  url = {https://github.com/CogniPilot/cyecca},
  year = {2025}
}
```
